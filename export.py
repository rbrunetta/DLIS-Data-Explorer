import streamlit as st
import pandas as pd
import lasio
import io
import os

def convert_depth_units(df, depth_column, from_unit, to_unit):
    """
    Converts the depth column from one unit to another.
    Returns the DataFrame with the converted depth column.
    """
    if from_unit == to_unit or from_unit in ['index', 'unknown'] or to_unit in ['index', 'unknown']:
        return df
    
    METERS_TO_FEET = 3.28084
    FEET_TO_METERS = 1 / METERS_TO_FEET
    
    df_converted = df.copy()
    
    if from_unit.lower() in ['m', 'meters', 'metres'] and to_unit.lower() in ['ft', 'feet']:
        df_converted[depth_column] = df_converted[depth_column] * METERS_TO_FEET
    elif from_unit.lower() in ['ft', 'feet'] and to_unit.lower() in ['m', 'meters', 'metres']:
        df_converted[depth_column] = df_converted[depth_column] * FEET_TO_METERS
    else:
        st.warning(f"Unit conversion not supported: from {from_unit} to {to_unit}. Keeping original unit.")
    
    return df_converted

def combine_dataframes(selected_curves, logical_file_dfs, export_unit):
    """
    Combines DataFrames from different Logical Files into a single DataFrame,
    aligning the data based on depth channels and converting to the desired unit.
    """
    if not selected_curves:
        return None
    
    dfs_to_combine = {}
    depth_columns = {}
    depth_units = {}
    
    for curve_info in selected_curves:
        logical_file_key = curve_info['logical_file_key']
        curve_name = curve_info['curve']
        depth_column = curve_info['depth_column']
        depth_unit = curve_info['depth_unit']
        
        if logical_file_key not in dfs_to_combine:
            if logical_file_key in logical_file_dfs:
                df = logical_file_dfs[logical_file_key][[depth_column, curve_name]].copy()
                df = convert_depth_units(df, depth_column, depth_unit, export_unit)
                dfs_to_combine[logical_file_key] = df
                depth_columns[logical_file_key] = depth_column
                depth_units[logical_file_key] = export_unit
            else:
                st.warning(f"Data for {logical_file_key} not found. Some curves may be missing.")
                continue
        else:
            if curve_name in logical_file_dfs[logical_file_key].columns:
                dfs_to_combine[logical_file_key][curve_name] = logical_file_dfs[logical_file_key][curve_name]
    
    if not dfs_to_combine:
        st.error("No valid data found for the selected curves.")
        return None
    
    reference_key = list(dfs_to_combine.keys())[0]
    reference_df = dfs_to_combine[reference_key]
    reference_depth = depth_columns[reference_key]
    
    combined_df = reference_df.rename(columns={reference_depth: 'DEPTH'})
    
    for key, df in dfs_to_combine.items():
        if key == reference_key:
            continue
        
        depth_col = depth_columns[key]
        if depth_col not in df.columns:
            st.warning(f"Depth channel {depth_col} not found in {key}. Ignoring curves from this Logical File.")
            continue
        
        df = df.rename(columns={depth_col: 'DEPTH'})
        
        combined_df = pd.merge(combined_df, df, on='DEPTH', how='outer')
    
    return combined_df

def create_las_file(df, curves, depth_column='DEPTH', depth_unit='unknown'):
    """
    Creates a LAS file in memory from a DataFrame, a list of selected curves, and the depth channel.
    The depth channel is 'DEPTH' (default after combination).
    Returns the LAS file content as a BytesIO object.
    """
    las = lasio.LASFile()
    las.well.WELL.value = "WELL"
    
    las.other = f"Depth unit: {depth_unit}\nGenerated by DLIS Data Explorer"
    
    if depth_column in df.columns:
        las.append_curve_item(lasio.CurveItem(mnemonic=depth_column, unit=depth_unit, data=df[depth_column]))
    else:
        st.error(f"Error: Depth channel '{depth_column}' not found in the combined DataFrame.")
        return None
    
    for curve in curves:
        if curve in df.columns and curve != depth_column:
            las.append_curve_item(lasio.CurveItem(mnemonic=curve, unit='', data=df[curve]))
    
    las_buffer = io.StringIO()
    las.write(las_buffer, version=2.0)
    las_buffer.seek(0)
    
    las_bytes = las_buffer.getvalue().encode('utf-8')
    return las_bytes

def export():
    """
    Displays the export interface for the LAS file.
    Combines data from multiple Logical Files, allows the user to remove selected curves,
    and choose the export unit (meters or feet).
    """
    st.header("Export to LAS")
    
    if 'selected_curves' not in st.session_state or not st.session_state.selected_curves:
        st.warning("No curves selected for export. Please select curves on the 'Data Visualization' page.")
        return
    
    if 'logical_file_dfs' not in st.session_state:
        st.warning("No Logical File data available. Please visualize the data on the 'Data Visualization' page.")
        return
    
    st.write("### Selected Channels to Export")
    for i, curve_info in enumerate(st.session_state.selected_curves):
        curve_name = curve_info['curve']
        logical_file = curve_info['logical_file']
        frame = curve_info['frame']
        depth_column = curve_info['depth_column']
        depth_unit = curve_info['depth_unit']
        
        col1, col2 = st.columns([4, 1])
        
        with col1:
            st.write(f"- **{curve_name}** ({logical_file}, {frame}, Depth: {depth_column}, Unit: {depth_unit})")
        
        with col2:
            if st.button("Remove", key=f"remove_{i}"):
                st.session_state.selected_curves.pop(i)
                st.success(f"Channel {curve_name} removed successfully!")
                st.rerun()
    
    if not st.session_state.selected_curves:
        st.warning("No curves selected for export. Please select curves on the 'Data Visualization' page.")
        return
    
    st.write("### Select Export Unit")
    export_unit = st.selectbox(
        "Choose the unit for depth in the exported LAS file:",
        options=['m (meters)', 'ft (feet)'],
        help="Select the unit of measurement for the depth channel in the exported LAS file."
    )
    export_unit_short = export_unit.split()[0]
    
    st.write(f"***- DEPTH (depth, unit: {export_unit_short}) - included by default (combined from selected Logical Files) -***")
    
    combined_df = combine_dataframes(st.session_state.selected_curves, st.session_state.logical_file_dfs, export_unit_short)
    if combined_df is None:
        return
    
    if 'uploaded_file_name' in st.session_state:
        dlis_file_name = st.session_state.uploaded_file_name
        default_file_name = os.path.splitext(dlis_file_name)[0] + ".las"
    else:
        default_file_name = "output.las"
    
    file_name = st.text_input("Type the name of the file (ex: output.las):", default_file_name)
    
    try:
        curves_to_export = [curve_info['curve'] for curve_info in st.session_state.selected_curves]
        las_bytes = create_las_file(combined_df, curves_to_export, depth_column='DEPTH', depth_unit=export_unit_short)
        
        if las_bytes is None:
            return
        
        st.download_button(
            label="Download LAS",
            data=las_bytes,
            file_name=file_name,
            mime="application/octet-stream"
        )
    except Exception as e:
        st.error(f"Error generating the LAS file: {e}")