import streamlit as st
import pandas as pd
import lasio
import io
import os

# Function to convert depth units
def convert_depth_units(df, depth_column, from_unit, to_unit):
    """
    Converts the depth column from one unit to another.
    Returns the DataFrame with the converted depth column.
    """
    if from_unit == to_unit or from_unit in ['index', 'unknown'] or to_unit in ['index', 'unknown']:
        return df  # No conversion needed
    
    # Conversion factors
    METERS_TO_FEET = 3.28084
    FEET_TO_METERS = 1 / METERS_TO_FEET
    
    df_converted = df.copy()
    
    if from_unit.lower() in ['m', 'meters', 'metres'] and to_unit.lower() in ['ft', 'feet']:
        df_converted[depth_column] = df_converted[depth_column] * METERS_TO_FEET
    elif from_unit.lower() in ['ft', 'feet'] and to_unit.lower() in ['m', 'meters', 'metres']:
        df_converted[depth_column] = df_converted[depth_column] * FEET_TO_METERS
    else:
        st.warning(f"Unit conversion not supported: from {from_unit} to {to_unit}. Keeping original unit.")
    
    return df_converted

# Function to combine DataFrames from different Logical Files
def combine_dataframes(selected_curves, logical_file_dfs, export_unit):
    """
    Combines DataFrames from different Logical Files into a single DataFrame,
    aligning the data based on depth channels and converting to the desired unit.
    """
    if not selected_curves:
        return None
    
    # Group curves by Logical File and Frame (logical_file_key)
    dfs_to_combine = {}
    depth_columns = {}
    depth_units = {}
    
    for curve_info in selected_curves:
        logical_file_key = curve_info['logical_file_key']
        curve_name = curve_info['curve']
        depth_column = curve_info['depth_column']
        depth_unit = curve_info['depth_unit']
        
        if logical_file_key not in dfs_to_combine:
            if logical_file_key in logical_file_dfs:
                # Copy the DataFrame and convert the depth unit
                df = logical_file_dfs[logical_file_key][[depth_column, curve_name]].copy()
                df = convert_depth_units(df, depth_column, depth_unit, export_unit)
                dfs_to_combine[logical_file_key] = df
                depth_columns[logical_file_key] = depth_column
                depth_units[logical_file_key] = export_unit  # Unit after conversion
            else:
                st.warning(f"Data for {logical_file_key} not found. Some curves may be missing.")
                continue
        else:
            # Add the curve to the existing DataFrame
            if curve_name in logical_file_dfs[logical_file_key].columns:
                dfs_to_combine[logical_file_key][curve_name] = logical_file_dfs[logical_file_key][curve_name]
    
    if not dfs_to_combine:
        st.error("No valid data found for the selected curves.")
        return None
    
    # Choose the reference depth channel (from the first Logical File)
    reference_key = list(dfs_to_combine.keys())[0]
    reference_df = dfs_to_combine[reference_key]
    reference_depth = depth_columns[reference_key]
    
    # Rename the reference depth column to a common name
    combined_df = reference_df.rename(columns={reference_depth: 'DEPTH'})
    
    # Combine the other DataFrames
    for key, df in dfs_to_combine.items():
        if key == reference_key:
            continue
        
        depth_col = depth_columns[key]
        if depth_col not in df.columns:
            st.warning(f"Depth channel {depth_col} not found in {key}. Ignoring curves from this Logical File.")
            continue
        
        # Rename the depth column to align
        df = df.rename(columns={depth_col: 'DEPTH'})
        
        # Merge the DataFrames based on depth (DEPTH)
        combined_df = pd.merge(combined_df, df, on='DEPTH', how='outer')
    
    return combined_df

# Function to create a LAS file in memory
def create_las_file(df, curves, depth_column='DEPTH', depth_unit='unknown'):
    """
    Creates a LAS file in memory from a DataFrame, a list of selected curves, and the depth channel.
    The depth channel is 'DEPTH' (default after combination).
    Returns the LAS file content as a BytesIO object.
    """
    las = lasio.LASFile()
    las.well.WELL.value = "WELL"  # Well name (can be customized)
    
    # Add the depth unit information in the ~Other block (comments)
    las.other = f"Depth unit: {depth_unit}\nGenerated by DLIS Data Explorer"
    
    # Add the depth curve with its unit
    if depth_column in df.columns:
        las.append_curve_item(lasio.CurveItem(mnemonic=depth_column, unit=depth_unit, data=df[depth_column]))
    else:
        st.error(f"Error: Depth channel '{depth_column}' not found in the combined DataFrame.")
        return None
    
    # Add the selected curves to the LAS file
    for curve in curves:
        if curve in df.columns and curve != depth_column:  # Avoid duplicating the depth curve
            # For now, we don't have unit information for other curves; set as empty
            las.append_curve_item(lasio.CurveItem(mnemonic=curve, unit='', data=df[curve]))
    
    # Create a memory buffer to store the LAS file
    las_buffer = io.StringIO()  # Use StringIO to store the content as a string
    las.write(las_buffer, version=2.0)
    las_buffer.seek(0)  # Go back to the beginning of the buffer for reading
    
    # Convert the content to bytes
    las_bytes = las_buffer.getvalue().encode('utf-8')  # Encode the string to bytes
    return las_bytes

# Function to display the export interface
def export():
    """
    Displays the export interface for the LAS file.
    Combines data from multiple Logical Files, allows the user to remove selected curves,
    and choose the export unit (meters or feet).
    """
    st.header("Export to LAS")
    
    # Check if selected curves are available
    if 'selected_curves' not in st.session_state or not st.session_state.selected_curves:
        st.warning("No curves selected for export. Please select curves on the 'Data Visualization' page.")
        return
    
    # Check if DataFrames for Logical Files are available
    if 'logical_file_dfs' not in st.session_state:
        st.warning("No Logical File data available. Please visualize the data on the 'Data Visualization' page.")
        return
    
    # Display the selected curves with Logical File, Frame, and depth unit information
    st.write("### Selected Channels to Export")
    for i, curve_info in enumerate(st.session_state.selected_curves):
        curve_name = curve_info['curve']
        logical_file = curve_info['logical_file']
        frame = curve_info['frame']
        depth_column = curve_info['depth_column']
        depth_unit = curve_info['depth_unit']
        
        # Create two columns: one for the curve text and one for the remove button
        col1, col2 = st.columns([4, 1])
        
        with col1:
            st.write(f"- **{curve_name}** ({logical_file}, {frame}, Depth: {depth_column}, Unit: {depth_unit})")
        
        with col2:
            if st.button("Remove", key=f"remove_{i}"):
                # Remove the curve from the list
                st.session_state.selected_curves.pop(i)
                st.success(f"Channel {curve_name} removed successfully!")
                # Force page re-render to update the list
                st.rerun()
    
    # Check if there are still selected curves after removal
    if not st.session_state.selected_curves:
        st.warning("No curves selected for export. Please select curves on the 'Data Visualization' page.")
        return
    
    # Option for the user to choose the export unit
    st.write("### Select Export Unit")
    export_unit = st.selectbox(
        "Choose the unit for depth in the exported LAS file:",
        options=['m (meters)', 'ft (feet)'],
        help="Select the unit of measurement for the depth channel in the exported LAS file."
    )
    export_unit_short = export_unit.split()[0]  # 'm' or 'ft'
    
    # Display the included depth channel
    st.write(f"***- DEPTH (depth, unit: {export_unit_short}) - included by default (combined from selected Logical Files) -***")
    
    # Combine the DataFrames from Logical Files, converting to the selected unit
    combined_df = combine_dataframes(st.session_state.selected_curves, st.session_state.logical_file_dfs, export_unit_short)
    if combined_df is None:
        return
    
    # Get the name of the uploaded DLIS file
    if 'uploaded_file_name' in st.session_state:
        dlis_file_name = st.session_state.uploaded_file_name
        default_file_name = os.path.splitext(dlis_file_name)[0] + ".las"  # Replace the extension with .las
    else:
        default_file_name = "output.las"  # Default name if the file name is not available
    
    # Field for the user to enter the file name
    file_name = st.text_input("Type the name of the file (ex: output.las):", default_file_name)
    
    # Generate the LAS file and display the download button
    try:
        # Create the LAS file in memory
        curves_to_export = [curve_info['curve'] for curve_info in st.session_state.selected_curves]
        las_bytes = create_las_file(combined_df, curves_to_export, depth_column='DEPTH', depth_unit=export_unit_short)
        
        if las_bytes is None:
            return  # If there was an error creating the LAS, stop
        
        # Display the download button
        st.download_button(
            label="Download LAS",
            data=las_bytes,  # Pass the content as bytes
            file_name=file_name,
            mime="application/octet-stream"
        )
    except Exception as e:
        st.error(f"Error generating the LAS file: {e}")